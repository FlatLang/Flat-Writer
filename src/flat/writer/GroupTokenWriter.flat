package flat/writer

import flat/ast
import flat/parser/matchers
import flat/compiler/models
import flat/log

import flat/writer/WriterPatternExtensions
import flat/stream/StreamListExtensions

import static flat/colorizer/Colorizer

data class extends TokenWriter {
  static Logger log = Logger(GroupTokenWriter.class)

  GroupTokenPattern pattern

  var Bool wasRepeat = false
  var TokenWriter currentWriter
  var Node parentNode

  lazy TokenWriter[] writers => pattern.patterns.stream()
    .filter({ !_.class.isOfType(PreconditionTokenPattern.class) })
    .map({ _.getWriter() })
    .toArray()

  lazy ArrayIterator<TokenWriter> iterator => writers.iterator

  override public validNodes(Node[] nodes) => true {
    log.traceFunc({"Checking if nodes are valid [#{nodes.map(n => green(n.class.name)).join(", ")}] for pattern #{magenta(pattern.toPatternString())}"})
    let it = writers.filter({ _.consumesNode() }).iterator

    for (node in nodes) {
      if (!it.hasNext) return false
      it.stepNext

      log.traceFunc({"Checking node #{green(node.class.name)} against pattern #{magenta(it.current.pattern.toPatternString())}"})
      while (!it.current.validNode(node)) {
        log.traceFunc({"Node #{green(node.class.name)} is not valid"})
        if (!it.hasNext || !it.current.pattern.optional) return false

        it.stepNext
        log.traceFunc({"Checking node #{green(node.class.name)} against pattern #{magenta(it.current.pattern.toPatternString())}"})
      }
    }

    while (it.hasNext) {
      if (it.stepNext.requiresNode()) {
        log.traceFunc({"Missing required nodes for pattern #{magenta(pattern.toPatternString())}"})
        return false
      }
    }

    log.traceFunc({"Nodes are valid for pattern #{magenta(pattern.toPatternString())}"})
  }

  override public consumesNode() -> Bool {
    if (currentWriter == null && !hasNextWriter()) return false
    if (currentWriter == null) nextWriter()

    return currentWriter.consumesNode() || iterator.allNext.any({ _.consumesNode() })
  }

  override public requiresNode() -> Bool {
    return iterator.allNextInclusive.any({ _.requiresNode() })
  }

  override public exhaust(WriterOutputStream output) {
    log.infoFunc({"Ending current writer #{magenta(pattern.toPatternString())}"})

    if (currentWriter && !currentWriter.requiresNode()) {
      currentWriter.exhaust(output)
    }

    while (hasNextWriter()) {
      nextWriter()

      if (!currentWriter.requiresNode()) {
        currentWriter.writePrimitiveTokens(output, null)
        currentWriter.exhaust(output)
      }
    }

    exhausted = true
  }

  hasNextWriter() -> Bool {
    return iterator.hasNext
  }

  nextWriter() => currentWriter {
    currentWriter = iterator.stepNext
    wasRepeat = false
  }

  repeatWriter() {
    log.traceFunc({"Repeating currentWriter: " + magenta(currentWriter.pattern.toPatternString())})
    currentWriter = currentWriter.pattern.getWriter()
    wasRepeat = true
  }

  override public validNode(Node node) -> Bool {
    return validNode(node, true)
  }

  validNode(Node node, Bool topLevel) -> Bool {
    if (node == null) return false
    if (super.validNode(node)) return true
    if (currentWriter == null && pattern.getNodeType() != Node.class) return false
    if (currentWriter == null && !hasNextWriter()) return false
    if (currentWriter == null) nextWriter()

    log.infoFunc({"|
      Checking node type #{green(node.class.name)} against writer #{magenta(currentWriter.pattern.toPatternString())}
        consumesNode: #{currentWriter.consumesNode()}
      |"})

    let bareNodePattern = currentWriter.pattern.getNodeType() == Node.class

    Logger.increaseTab()
    let currentValid = !bareNodePattern && node.class == currentWriter.pattern.getNodeType() ||
      bareNodePattern && currentWriter.consumesNode() && currentWriter.validNode(node)
    Logger.decreaseTab()

    if (currentValid) {
      log.infoFunc({"Valid node for writer #{magenta(currentWriter.pattern.toPatternString())}"})
      return true
    } else {
      currentWriter.reset()
      if (bareNodePattern && !currentWriter.consumesNode()) {
        log.infoFunc({"Bare node does not consume any nodes. Writing primitive tokens #{magenta(currentWriter.pattern.toPatternString())}"})
        currentWriter.writePrimitiveTokens(buffer, node)
      }
    }
    if (!hasNextWriter()) {
      log.infoFunc({"No more writers. Not valid #{magenta(currentWriter.pattern.toPatternString())}"})
      log.infoFunc({"Clearing buffered data: #{buffer.buffer}"})
      buffer.clear()
      return false
    }

    let writer = currentWriter

    nextWriter()
    log.infoFunc({"Node #{green(node.class.name)} is not valid for current writer. Checking nextWriter #{magenta(currentWriter.pattern.toPatternString())}"})

    if (validNode(node, false)) {
      if (topLevel) {
        currentWriter.reset()
      }
      log.infoFunc({"|
        Found valid writer for node #{magenta(currentWriter.pattern.toPatternString())}
          buffer: #{buffer.buffer}
        |"})

      return true
    } else {
      log.infoFunc({"|
        Node #{green(node.class.name)} is not valid for writer.
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      currentWriter = writer
      log.infoFunc({"Clearing buffered data: #{buffer.buffer}"})
      buffer.clear()
      return false
    }
  }

  initCurrentWriter() => true {
    if (!currentWriter) {
      if (hasNextWriter()) {
        nextWriter()
      } else {
        log.traceFunc({"No more writers. Exhausted"})
        exhausted = true
        return false
      }
    }
  }

  override public write(WriterOutputStream output, Node node) {
    if (exhausted) return
    if (!initCurrentWriter()) return

    innerWrite(output, node)

    if (currentWriter.exhausted) {
      if (hasNextWriter()) {
        nextWriter()
      } else {
        exhausted = true
      }
    }
  }

  innerWrite(WriterOutputStream output, Node node) {
    if (buffer.buffer.isNotEmpty) {
      log.infoFunc({"Writing buffered data: #{buffer.buffer}"})
      buffer.buffer.forEach({ output.writeObject(_) })
      buffer.clear()
    }

    if (!writePrimitiveTokens(output, node)) {
      return
    }

    if (!currentWriter.validNode(node)) {
      if (!hasNextWriter() || !iterator.next.validNode(node)) {
        buffer.clear()
        parentNode = node
        log.infoFunc({"|
          Node #{green(node?.class.name)} is not valid for current writer #{green(currentWriter.class.name)}. Awaiting child node
            pattern: #{magenta(currentWriter.pattern.toPatternString())}
          |"})
        return
      }
      nextWriter()
    }

    log.infoFunc({"|
      Writing node #{green(node?.class.name)} to currentWriter #{green(currentWriter.class.name)}
        pattern: #{magenta(currentWriter.pattern.toPatternString())}
      |"})
    Logger.increaseTab()
    currentWriter.write(output, node)
    Logger.decreaseTab()
  }

  override public writePrimitiveTokens(WriterOutputStream output, Node node) => true {
    initCurrentWriter()

    while (!currentWriter.consumesNode()) {
      log.infoFunc({"|
        Writing primitive Token to currentWriter #{green(currentWriter.class.name)}
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      Logger.increaseTab()
      currentWriter.writePrimitiveTokens(output, node)
      Logger.decreaseTab()

      if (!currentWriter.exhausted || !hasNextWriter()) {
        return false
      }

      nextWriter()
    }
  }

  override public reset() {
    super.reset()

    wasRepeat = false
    currentWriter = null
    iterator.reset()
    writers.forEach({ _.reset() })
  }
}