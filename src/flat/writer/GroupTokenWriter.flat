package flat/writer

import flat/ast
import flat/parser/matchers
import flat/compiler/models
import flat/log

import flat/writer/WriterPatternExtensions

import static flat/colorizer/Colorizer

data class extends TokenWriter {
  static Logger log = Logger(GroupTokenWriter.class)

  GroupTokenPattern pattern

  var Bool wasRepeat = false
  var TokenWriter currentWriter
  var Node parentNode

  lazy ArrayIterator<TokenWriter> iterator => pattern.patterns.map({ _.getWriter() }).iterator

  override public consumesNode() -> Bool {
    if (currentWriter == null && !hasNextWriter()) return false
    if (currentWriter == null) nextWriter()

    return currentWriter.consumesNode() || iterator.allNext.any({ _.consumesNode() })
  }

  override public requiresNode() -> Bool {
    return iterator.allNextInclusive.any({ _.requiresNode() })
  }

  override public endCurrentWriter(WriterOutputStream output) {
    log.infoFunc({"Ending current writer #{magenta(pattern.toPatternString())}"})

    if (currentWriter && !currentWriter.requiresNode()) {
      currentWriter.endCurrentWriter(output)
    }

    while (hasNextWriter()) {
      nextWriter()

      if (!currentWriter.requiresNode()) {
        currentWriter.write(output, null)
        currentWriter.endCurrentWriter(output)
      }
    }

    exhausted = true
  }

  hasNextWriter() -> Bool {
    return iterator.hasNext
  }

  nextWriter() {
    currentWriter = iterator.stepNext
    wasRepeat = false
  }

  repeatWriter() {
    log.traceFunc({"Repeating currentWriter: " + magenta(currentWriter.pattern.toPatternString())})
    currentWriter = currentWriter.pattern.getWriter()
    wasRepeat = true
  }

  override public validNode(Node node) -> Bool {
    return validNode(node, true)
  }

  validNode(Node node, Bool topLevel) -> Bool {
    buffer.clear()

    if (node == null) return false
    if (super.validNode(node)) return true
    if (currentWriter == null && pattern.getNodeType() != Node.class) return false
    if (currentWriter == null && !hasNextWriter()) return false
    if (currentWriter == null) nextWriter()

    log.infoFunc({"|
      Checking node type #{green(node.class.name)} against writer #{magenta(currentWriter.pattern.toPatternString())}
        consumesNode: #{currentWriter.consumesNode()}
      |"})

    Logger.increaseTab()
    let currentValid = currentWriter.consumesNode() && currentWriter.validNode(node)
    Logger.decreaseTab()

    if (currentValid) {
      log.infoFunc({"Valid node for writer #{magenta(currentWriter.pattern.toPatternString())}"})
      return true
    }
    if (!hasNextWriter()) {
      log.infoFunc({"No more writers. Not valid #{magenta(currentWriter.pattern.toPatternString())}"})
      log.infoFunc({"Clearing buffered data: #{buffer.buffer}"})
      buffer.clear()
      return false
    }

    let writer = currentWriter

    nextWriter()
    log.infoFunc({"Node #{green(node.class.name)} is not valid for current writer. Checking nextWriter #{magenta(currentWriter.pattern.toPatternString())}"})

    if (validNode(node, false)) {
      if (topLevel) {
        currentWriter.reset()
        currentWriter.writePrimitiveTokens(buffer, node)
      }
      log.infoFunc({"|
        Found valid writer for node #{magenta(currentWriter.pattern.toPatternString())}
          buffer: #{buffer.buffer}
        |"})

      return true
    } else {
      log.infoFunc({"|
        Node #{green(node.class.name)} is not valid for writer.
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      currentWriter = writer
      log.infoFunc({"Clearing buffered data: #{buffer.buffer}"})
      buffer.clear()
      return false
    }
  }

  initCurrentWriter() => true {
    if (!currentWriter) {
      if (hasNextWriter()) {
        nextWriter()
      } else {
        log.traceFunc({"No more writers. Exhausted"})
        exhausted = true
        return false
      }
    }
  }

  override public write(WriterOutputStream output, Node node) {
    if (exhausted) return
    if (!initCurrentWriter()) return

    innerWrite(output, node)

    if (currentWriter.exhausted) {
      if (hasNextWriter()) {
        nextWriter()
      } else {
        exhausted = true
      }
    }
  }

  innerWrite(WriterOutputStream output, Node node) {
    if (buffer.buffer.isNotEmpty) {
      log.infoFunc({"Writing buffered data: #{buffer.buffer}"})
      buffer.buffer.forEach({ output.writeObject(_) })
      buffer.clear()
    }

    if (!writePrimitiveTokens(output, node)) {
      return
    }

    if (!currentWriter.validNode(node)) {
      buffer.clear()
      parentNode = node
      log.infoFunc({"|
        Node #{green(node?.class.name)} is not valid for current writer #{green(currentWriter.class.name)}. Awaiting child node
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      return
    }

    log.infoFunc({"|
      Writing node #{green(node?.class.name)} to currentWriter #{green(currentWriter.class.name)}
        pattern: #{magenta(currentWriter.pattern.toPatternString())}
      |"})
    Logger.increaseTab()
    currentWriter.write(output, node)
    Logger.decreaseTab()
  }

  override public writePrimitiveTokens(WriterOutputStream output, Node node) => true {
    initCurrentWriter()

    while (!currentWriter.consumesNode()) {
      log.infoFunc({"|
        Writing primitive Token to currentWriter #{green(currentWriter.class.name)}
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      Logger.increaseTab()
      currentWriter.writePrimitiveTokens(output, node)
      Logger.decreaseTab()

      if (!currentWriter.exhausted || !hasNextWriter()) {
        return false
      }

      nextWriter()
    }
  }

  reset() {
    super.reset()

    wasRepeat = false
    currentWriter = null
    iterator.reset()
  }
}