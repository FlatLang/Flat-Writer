package flat/writer

import flat/ast
import flat/parser/matchers
import flat/log

import flat/writer/WriterPatternExtensions

import static flat/colorizer/Colorizer

data class extends TokenWriter {
  static Logger log = Logger(GroupTokenWriter.class)

  GroupTokenPattern pattern

  var Bool wasRepeat = false
  var TokenWriter currentWriter
  var Node parentNode

  lazy ArrayIterator<TokenWriter> iterator => pattern.patterns.map({ _.getWriter() }).iterator

  override public consumesNode() -> Bool {
    if (currentWriter == null && !hasNextWriter()) return false
    if (currentWriter == null) nextWriter()

    return currentWriter.consumesNode()
  }

  hasNextWriter() -> Bool {
    return iterator.hasNext
  }

  nextWriter() {
    currentWriter = iterator.stepNext
    wasRepeat = false
  }

  repeatWriter() {
    log.traceFunc({"Repeating currentWriter: " + magenta(currentWriter.pattern.toPatternString())})
    currentWriter = currentWriter.pattern.getWriter()
    wasRepeat = true
  }

  override public validNode(Node node) -> Bool {
    if (super.validNode(node)) return true
    if (currentWriter == null && pattern.getNodeType() != Node.class) return false
    if (currentWriter == null && !hasNextWriter()) return false
    if (currentWriter == null) nextWriter()

    log.infoFunc({"|
      Checking node type #{green(node.class.name)} against writer #{magenta(currentWriter.pattern.toPatternString())}
        consumesNode: #{currentWriter.consumesNode()}
      |"})

    Logger.increaseTab()
    let currentValid = currentWriter.consumesNode() && currentWriter.validNode(node)
    Logger.decreaseTab()

    if (currentValid) {
      log.infoFunc({"Valid node for writer #{magenta(currentWriter.pattern.toPatternString())}"})
      return true
    }
    if (!hasNextWriter()) {
      log.infoFunc({"No more writers. Not valid #{magenta(currentWriter.pattern.toPatternString())}"})
      return false
    }

    nextWriter()
    log.infoFunc({"Node #{green(node.class.name)} is not valid for current writer. Checking nextWriter #{magenta(currentWriter.pattern.toPatternString())}"})

    if (validNode(node)) {
      currentWriter.reset()
      log.infoFunc({"Found valid writer for node #{magenta(currentWriter.pattern.toPatternString())}"})

      return true
    } else {
      log.infoFunc({"|
        Node #{green(node.class.name)} is not valid for writer. Exhausted
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      exhausted = true
      return false
    }
  }

  override public write(WriterOutputStream output, Node node) {
    if (exhausted) return
    if (!currentWriter) {
      if (hasNextWriter()) {
        nextWriter()
      } else {
        log.traceFunc({"No more writers. Exhausted"})
        exhausted = true
        return
      }
    }

    innerWrite(output, node)
  }

  innerWrite(WriterOutputStream output, Node node) {
    while (!currentWriter.consumesNode()) {
      log.infoFunc({"|
        Writing node #{green(node.class.name)} to currentWriter #{green(currentWriter.class.name)}
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      Logger.increaseTab()
      currentWriter.write(output, node)
      Logger.decreaseTab()

      if (!currentWriter.exhausted || !hasNextWriter()) {
        return
      }

      nextWriter()
    }

    if (!currentWriter.validNode(node)) {
      parentNode = node
      log.infoFunc({"|
        Node #{green(node.class.name)} is not valid for current writer #{green(currentWriter.class.name)}. Awaiting child node
          pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      return
    }

    log.infoFunc({"|
      Writing node #{green(node.class.name)} to currentWriter #{green(currentWriter.class.name)}
        pattern: #{magenta(currentWriter.pattern.toPatternString())}
      |"})
    Logger.increaseTab()
    currentWriter.write(output, node)
    Logger.decreaseTab()

    if (currentWriter.exhausted) {
      if (hasNextWriter()) {
        nextWriter()
      } else {
        exhausted = true
      }
    }
  }

  reset() {
    super.reset()

    wasRepeat = false
    currentWriter = null
    iterator.reset()
  }
}