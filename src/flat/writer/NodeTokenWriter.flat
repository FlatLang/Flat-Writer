package flat/writer

import flat/ast
import flat/parser/matchers
import flat/log

import flat/writer/WriterPatternExtensions

import static flat/colorizer/Colorizer

data class extends TokenWriter {
  static Logger log = Logger(NodeTokenWriter.class)

  NodeTokenPattern pattern

  var TokenWriter writer

  override public validNode(Node node) -> Bool {
    if (node == null) return false
    if (super.validNode(node)) return true
    if (writer == null) searchWriter(node)
    if (writer == null) return false

    log.infoFunc({"Checking node type #{green(node.class.name)} against writer #{magenta(writer.pattern.toPatternString())}"})

    Logger.increaseTab()
    let valid = writer.validNode(node)
    Logger.decreaseTab()

    return valid
  }

  override public consumesNode() => true

  override public endCurrentWriter(WriterOutputStream output) {
    log.infoFunc({"Ending current writer"})

    if (writer) {
      writer.endCurrentWriter(output)
    }

    exhausted = true
  }

  searchWriter(Node node) {
    writer = pattern.parsers.firstWhere({ _.pattern.getNodeType() == node.class })?.pattern.getWriter()

    if (!writer) {
      writer = pattern.parsers.firstWhere({ node.class.isOfType(_.pattern.getNodeType()) })?.pattern.getWriter()
    }
  }

  override public write(WriterOutputStream output, Node node) {
    if (!writer) {
      searchWriter(node)

      if (!writer) {
        log.infoFunc({"Unable to determine writer for Node pattern for node type #{green(node.class.name)}. Exhausted"})
        exhausted = true
        return
      }
    }

    innerWrite(output, node)
  }

  innerWrite(WriterOutputStream output, Node node) {
    log.infoFunc({"|
      Writing node #{green(node.class.name)} to writer #{green(writer.class.name)}
        pattern: #{magenta(writer.pattern.toPatternString())}
      |"})
    Logger.increaseTab()
    writer.write(output, node)
    Logger.decreaseTab()

    exhausted = writer.exhausted
  }
}