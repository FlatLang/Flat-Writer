package flat/writer

import flat/ast
import flat/datastruct
import flat/datastruct/list
import flat/parser
import flat/parser/matchers
import flat/log

import flat/writer/WriterPatternExtensions

import static flat/colorizer/Colorizer

data class extends TokenWriter {
  static Logger log = Logger(NodeGroupTokenWriter.class)

  NodeGroupTokenPattern pattern

  Stack<HashMap<Class<Node>, TokenWriter>> writerMaps = Stack([HashMap()])
  Stack<HashMap<Class<Node>, ParserBase>> parserMaps = Stack([HashMap()])

  HashMap<Class<Node>, TokenWriter> writerMap => writerMaps.peek()
  HashMap<Class<Node>, ParserBase> parserMap => parserMaps.peek()

  var TokenWriter currentWriter
  var ParserBase currentParser
  var Bool awaitingChild

  override public validNode(Node node) -> Bool {
    if (node == null) return false
    if (currentWriter == null) {
      log.infoFunc({"Current writer is null. Seacrhing current writer"})
      searchCurrentWriter(node)

      if (currentWriter) {
        log.infoFunc({"Current writer found. Valid"})
        return true
      } else {
        log.infoFunc({"Current writer not found. Invalid"})
        return false
      }
    }
    if (super.validNode(node)) return true

    log.infoFunc({"Checking node type #{green(node.class.name)} against writer #{magenta(currentWriter?.pattern.toPatternString())}"})

    Logger.increaseTab()
    let valid = currentWriter?.validNode(node)
    Logger.decreaseTab()

    return valid
  }

  override public consumesNode() => true

  override public exhaust(WriterOutputStream output) => true {
    log.infoFunc({"Ending current writer"})

    if (!awaitingChild) {
      if (currentWriter) {
        Logger.increaseTab()
        if (!currentWriter.exhaust(output)) {
          Logger.decreaseTab()
          return false
        }
        Logger.decreaseTab()
        currentWriter = null
      }

      exhausted = true
      currentParser = null

      return true
    } else {
      log.infoFunc({"Was awaiting child"})
      awaitingChild = false
      currentParser = null

      return false
    }
  }

  initMaps() {
    pattern.parsers.forEach((parser) => {
      let pattern = parser.pattern
      let writer = pattern.getWriter()

      if (pattern.getNodeType() == Node.class) {
        if (writer.class.isOfType(NodeTokenWriter.class)) {
          let nodeWriter = (NodeTokenWriter)writer

          nodeWriter.getNodeTypes().forEach({ writerMap[_] = writer })
        } else {
          log.warnFunc({"Could not get node type for pattern #{magenta(pattern.toPatternString())}"})
        }
        return
      }

      writerMap[pattern.getNodeType()] = writer
      parserMap[pattern.getNodeType()] = parser
    })
  }

  searchCurrentWriter(Node node) {
    if (writerMap.isEmpty) {
      initMaps()
    }

    if (currentParser?.childParsers) {
      log.infoFunc({"currentParser.childParsers: #{currentParser.childParsers.map(p => p.class.name).join(", ")}"})
      var newParser = currentParser.childParsers.firstWhere({ node.class == _.pattern.getNodeType() })

      if (!newParser) {
        newParser = currentParser.childParsers.firstWhere({ node.class.isOfType(_.pattern.getNodeType()) })

        if (!newParser) {
          log.error("Invalid node type: '#{node.class.name}'")
          exhausted = true
          return
        }
      }

      currentParser = newParser
      currentWriter = currentParser.pattern.getWriter()
      return
    }

    log.infoFunc({"Searching for writer for node type #{green(node.class.name)} against writers: #{writerMap.keys.map(c => green(c.name)).join(", ")}"})
    currentWriter = writerMap[node.class]
    currentParser = parserMap[node.class]

    if (!currentWriter) {
      log.infoFunc({"Did not find exact writer. Searching for isOfType"})
      currentWriter = writerMap.firstWhere({ node.class.isOfType(_.key) })?.value
      currentParser = parserMap.firstWhere({ node.class.isOfType(_.key) })?.value

      if (!currentWriter) {
        log.infoFunc({"Could not get writer for node type #{green(node.class.name)}"})
      } else {
        log.infoFunc({"Got writer from isOfType #{green(writerMap.firstWhere(w => node.class.isOfType(w.key)).key.name)}"})
      }
    }

    if (currentParser?.childParsers) {
      awaitingChild = true
    }
  }

  override public write(WriterOutputStream output, Node node) {
    if (currentWriter) {
      log.infoFunc({"|
        Checking node type #{green(node.class.name)} validity for currentWriter
          currentWriter.pattern: #{magenta(currentWriter.pattern.toPatternString())}
        |"})
      Logger.increaseTab()
      if (!currentWriter.validNode(node)) {
        Logger.decreaseTab()
        log.infoFunc({"|
          Node #{green(node.class.name)} is not valid for currentWriter. Resetting current currentWriter
            currentWriter.pattern: #{magenta(currentWriter.pattern.toPatternString())}
          |"})
        currentWriter = null
        currentParser = null
      } else {
        Logger.decreaseTab()
      }
    }
    if (!currentWriter) {
      searchCurrentWriter(node)

      if (!currentWriter) {
        return
      }
    }

    innerWrite(output, node)
  }

  innerWrite(WriterOutputStream output, Node node) {
    log.infoFunc({"|
      Writing node #{green(node.class.name)} to writer #{green(currentWriter.class.name)}
        pattern: #{magenta(currentWriter.pattern.toPatternString())}
      |"})
    Logger.increaseTab()
    currentWriter.write(output, node)
    Logger.decreaseTab()

    if (currentWriter.exhausted) {
      currentWriter = null
      log.infoFunc({"Writer is exhausted"})
    } else {
      log.infoFunc({"Writer is not exhausted"})
    }
  }

  override public reset() {
    super.reset()

    awaitingChild = false
    currentWriter = null
    currentParser = null
  }
}