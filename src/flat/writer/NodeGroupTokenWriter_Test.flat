package flat/writer

import flat/ast
import flat/parser
import flat/parser/flat
import flat/parser/matchers
import flat/annotations
import flat/compiler/models
import flat/writer/TestOutputStream_Test.TestOutputStream

testable class {
  test `can write node group containing single node type`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      IdentifierParser()
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))

    expect(outputStream.output).toBe("<test>")
    expect(writer.exhausted).toBe(false)
  }

  test `can write node group containing single node type twice`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      IdentifierParser()
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))
    writer.write(outputStream, IdentifierNode(name: Token(value: "test2")))

    expect(outputStream.output).toBe("<test><test2>")
    expect(writer.exhausted).toBe(false)
  }

  test `can write node group containing two node types`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      IdentifierParser(),
      AssignmentParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, IdentifierNode(name: Token(value: "test2")))

    expect(outputStream.output).toBe("<=><test2>")
    expect(writer.exhausted).toBe(false)
  }

  test `can write klass with name then field`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
      FieldParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: Token(value: "class")))
    writer.write(outputStream, IdentifierNode(name: Token(value: "Bob")))
    writer.write(outputStream, FieldNode())
    writer.write(outputStream, TypeNode(name: Token(value: "String")))
    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))

    expect(outputStream.output).toBe("<class><Bob><{><String><test>")
    expect(writer.exhausted).toBe(false)
  }

  test `can write klass with implicit name then field`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
      FieldParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: Token(value: "class")))
    writer.write(outputStream, FieldNode())
    writer.write(outputStream, TypeNode(name: Token(value: "String")))
    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))

    expect(outputStream.output).toBe("<class><{><String><test>")
    expect(writer.exhausted).toBe(false)
  }

  test `can write complete klass with field`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: Token(value: "class")))
    writer.write(outputStream, FieldNode())
    writer.write(outputStream, TypeNode(name: Token(value: "String")))
    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.output).toBe("<class><{><String><test><}>")
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete empty klass`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: Token(value: "class")))
    writer.exhaust(outputStream)

    expect(outputStream.output).toBe("<class><{><}>")
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with empty function`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: Token(value: "class")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.output).toBe("<class><{><test><(><)><{><}><}>")
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with empty function with a modifier`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: Token(value: "class")))
    writer.write(outputStream, PublicModifier(aliasUsed: Token(type: Token.Type.IDENTIFIER, value: "public")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.output).toBe("<class><{><public><test><(><)><{><}><}>")
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with empty function with modifiers`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: Token(value: "class")))
    writer.write(outputStream, PublicModifier(aliasUsed: Token(type: Token.Type.IDENTIFIER, value: "public")))
    writer.write(outputStream, StaticModifier(aliasUsed: Token(type: Token.Type.IDENTIFIER, value: "static")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: Token(value: "test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.output).toBe("<class><{><public><static><test><(><)><{><}><}>")
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete function with no parameters and empty body`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      FunctionParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: Token(type: Token.Type.IDENTIFIER, value: "test")))
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      Token(type: Token.Type.IDENTIFIER, value: "test"),
      Token(type: Token.Type.SYMBOL, value: "("),
      Token(type: Token.Type.SYMBOL, value: ")"),
      Token(type: Token.Type.SYMBOL, value: "{"),
      Token(type: Token.Type.SYMBOL, value: "}"),
    ])
    expect(writer.exhausted).toBe(true)
  }
}
