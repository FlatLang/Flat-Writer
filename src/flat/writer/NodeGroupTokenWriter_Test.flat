package flat/writer

import flat/ast
import flat/parser
import flat/parser/flat
import flat/parser/matchers
import flat/annotations
import flat/compiler/models
import flat/writer/TestOutputStream_Test.TestOutputStream

testable class {
  test `can write node group containing single node type`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      IdentifierParser()
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, IdentifierNode(name: ident("test")))

    expect(outputStream.buffer).toBe([
      ident("test"),
    ])
    expect(writer.exhausted).toBe(false)
  }

  test `can write node group containing single node type twice`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      IdentifierParser()
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.exhaust(outputStream)
    writer.write(outputStream, IdentifierNode(name: ident("test2")))

    expect(outputStream.buffer).toBe([
      ident("test"),
      ident("test2"),
    ])
    expect(writer.exhausted).toBe(false)
  }

  test `can write node group containing two node types`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      IdentifierParser(),
      AssignmentParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, IdentifierNode(name: ident("test2")))

    expect(outputStream.buffer).toBe([ sym("="),
      ident("test2"),
    ])
    expect(writer.exhausted).toBe(false)
  }

  test `can write klass with name then field`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
      FieldParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, IdentifierNode(name: ident("Bob")))
    writer.write(outputStream, FieldNode())
    writer.write(outputStream, TypeNode(name: ident("String")))
    writer.write(outputStream, IdentifierNode(name: ident("test")))

    expect(outputStream.buffer).toBe([
      ident("class"), ident("Bob"), sym("{"),
        ident("String"), ident("test"),
    ])
    expect(writer.exhausted).toBe(false)
  }

  test `can write klass with implicit name then field`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
      FieldParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, FieldNode())
    writer.write(outputStream, TypeNode(name: ident("String")))
    writer.write(outputStream, IdentifierNode(name: ident("test")))

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
        ident("String"), ident("test"),
    ])
    expect(writer.exhausted).toBe(false)
  }

  test `can write complete klass with field`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, FieldNode())
    writer.write(outputStream, TypeNode(name: ident("String")))
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
        ident("String"), ident("test"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete empty klass`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with empty function`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
        ident("test"), sym("("), sym(")"), sym("{"),
        sym("}"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with empty function with a modifier`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, PublicModifier(aliasUsed: ident("public")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
        ident("public"), ident("test"), sym("("), sym(")"), sym("{"),
        sym("}"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with empty function with modifiers`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, PublicModifier(aliasUsed: ident("public")))
    writer.write(outputStream, StaticModifier(aliasUsed: ident("static")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
        ident("public"), ident("static"), ident("test"), sym("("), sym(")"), sym("{"),
        sym("}"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete function with no parameters and empty body`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      FunctionParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("test"), sym("("), sym(")"), sym("{"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete local declaration`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      AnnotationParser(),
      LocalDeclarationParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, LetModifier(aliasUsed: ident("let")))
    writer.write(outputStream, LocalDeclarationNode())
    writer.write(outputStream, IdentifierNode(name: ident("local")))
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("let"), ident("local"),
    ])
    expect(writer.exhausted).toBe(false)
    writer.exhaust(outputStream)
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete local declaration with assignment`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      AnnotationParser(),
      LocalDeclarationParser(),
      AssignmentParser(),
      LiteralParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, LetModifier(aliasUsed: ident("let")))
    writer.write(outputStream, LocalDeclarationNode())
    writer.write(outputStream, IdentifierNode(name: ident("local")))
    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, StringLiteralNode(value: str("\"hello, world!\"")))
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("let"), ident("local"), sym("="), str("\"hello, world!\""),
    ])
    expect(writer.exhausted).toBe(false)
    writer.exhaust(outputStream)
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete function with no parameters and identifier`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      FunctionParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.write(outputStream, IdentifierNode(name: ident("hey")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("test"), sym("("), sym(")"), sym("{"),
        ident("hey"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write assignment to variable`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      IdentifierParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, IdentifierNode(name: ident("local")))
    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, StringLiteralNode(value: str("\"hello, world!\"")))
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("local"), sym("="), str("\"hello, world!\""),
    ])
    expect(writer.exhausted).toBe(false)
    writer.exhaust(outputStream)
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete function with no parameters with local declaration`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      FunctionParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.write(outputStream, LetModifier(aliasUsed: ident("let")))
    writer.write(outputStream, LocalDeclarationNode())
    writer.write(outputStream, IdentifierNode(name: ident("local")))
    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, StringLiteralNode(value: str("\"hello, world!\"")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("test"), sym("("), sym(")"), sym("{"),
        ident("let"), ident("local"), sym("="), str("\"hello, world!\""),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with function with local declaration`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, PublicModifier(aliasUsed: ident("public")))
    writer.write(outputStream, StaticModifier(aliasUsed: ident("static")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.write(outputStream, LetModifier(aliasUsed: ident("let")))
    writer.write(outputStream, LocalDeclarationNode())
    writer.write(outputStream, IdentifierNode(name: ident("local")))
    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, StringLiteralNode(value: str("\"hello, world!\"")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
        ident("public"), ident("static"), ident("test"), sym("("), sym(")"), sym("{"),
          ident("let"), ident("local"), sym("="), str("\"hello, world!\""),
        sym("}"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  test `can write complete klass with function with multiple statements`() {
    let outputStream = TestOutputStream()
    let pattern = NodeGroupTokenPattern([
      ClassParser(),
    ])
    let writer = NodeGroupTokenWriter(pattern)

    writer.write(outputStream, ClassNode(type: ident("class")))
    writer.write(outputStream, PublicModifier(aliasUsed: ident("public")))
    writer.write(outputStream, StaticModifier(aliasUsed: ident("static")))
    writer.write(outputStream, FunctionNode())
    writer.write(outputStream, IdentifierNode(name: ident("test")))
    writer.write(outputStream, LetModifier(aliasUsed: ident("let")))
    writer.write(outputStream, LocalDeclarationNode())
    writer.write(outputStream, IdentifierNode(name: ident("local")))
    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, StringLiteralNode(value: str("\"hello, world!\"")))
    writer.exhaust(outputStream)
    writer.write(outputStream, LetModifier(aliasUsed: ident("let")))
    writer.write(outputStream, LocalDeclarationNode())
    writer.write(outputStream, IdentifierNode(name: ident("local2")))
    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, StringLiteralNode(value: str("\"hello, world2!\"")))
    writer.exhaust(outputStream)
    writer.write(outputStream, LetModifier(aliasUsed: ident("let")))
    writer.write(outputStream, LocalDeclarationNode())
    writer.write(outputStream, IdentifierNode(name: ident("local3")))
    writer.write(outputStream, AssignmentNode())
    writer.write(outputStream, StringLiteralNode(value: str("\"hello, world3!\"")))
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)
    writer.exhaust(outputStream)

    expect(outputStream.buffer).toBe([
      ident("class"), sym("{"),
        ident("public"), ident("static"), ident("test"), sym("("), sym(")"), sym("{"),
          ident("let"), ident("local"), sym("="), str("\"hello, world!\""),
          ident("let"), ident("local2"), sym("="), str("\"hello, world2!\""),
          ident("let"), ident("local3"), sym("="), str("\"hello, world3!\""),
        sym("}"),
      sym("}"),
    ])
    expect(writer.exhausted).toBe(true)
  }

  ident(String value) => Token(value: value, type: Token.Type.IDENTIFIER)
  sym(String value) => Token(value: value, type: Token.Type.SYMBOL)
  str(String value) => Token(value: value, type: Token.Type.STRING)
}
